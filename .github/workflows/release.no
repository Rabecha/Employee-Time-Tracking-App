name: CI/CD Release

on:
  push:
    tags:
      - 'v*.*.*'  # triggers on Git tags like v1.0.0

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    services:
      mysql:
        image: mysql:5.7
        env:
          MYSQL_ROOT_PASSWORD: rootpassword
          MYSQL_DATABASE: notesdb_test
          MYSQL_USER: notesuser_test
          MYSQL_PASSWORD: your_test_password
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping --silent"
          --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      # 1. Checkout code
      - name: Checkout repository
        uses: actions/checkout@v4

      # 2. Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      # 3. Install dependencies
      - name: Install dependencies
        run: npm ci

      # 4. Wait for MySQL to be ready
      - name: Wait for MySQL
        run: |
          for i in {1..30}; do
            mysql -h 127.0.0.1 -u root -prootpassword -e "SELECT 1" && break
            echo "Waiting for MySQL..."


            sleep 2
          done

      # 5. Run tests
      - name: Run tests
        env:
          DB_HOST: 127.0.0.1
          DB_USER: notesuser_test
          DB_PASSWORD: your_test_password
          DB_NAME: notesdb_test
          NODE_ENV: test
        run: npm test

      # 6. Build Docker image
      - name: Build Docker image
        run: docker build -t rabecha/employee-time-tracking-app:${GITHUB_REF#refs/tags/} .

      # 7. Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # 8. Push Docker image
      - name: Push Docker image
        run: docker push rabecha/employee-time-tracking-app:${GITHUB_REF#refs/tags/}
name: Release - Semantic Versioning

on:
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      release_notes:
        description: 'Release notes (optional)'
        required: false
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Get current version
      id: current_version
      run: |
        VERSION=$(node -p "require('./package.json').version")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $VERSION"

    - name: Calculate new version
      id: new_version
      run: |
        CURRENT=${{ steps.current_version.outputs.version }}
        BUMP=${{ github.event.inputs.version_bump }}
        
        # Parse version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
        
        case $BUMP in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"

    - name: Update package.json
      run: |
        npm version ${{ steps.new_version.outputs.new_version }} --no-git-tag-version
        echo "Updated package.json to version ${{ steps.new_version.outputs.new_version }}"

    - name: Generate changelog
      id: changelog
      run: |
        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          COMMITS=$(git log --oneline --all)
        else
          COMMITS=$(git log $LAST_TAG..HEAD --oneline)
        fi
        
        CHANGELOG="## What's Changed
        
        - Version bump: ${{ github.event.inputs.version_bump }}
        - New version: ${{ steps.new_version.outputs.new_version }}
        - Release date: $(date +'%Y-%m-%d')
        
        ## Commits
        
        \`\`\`
        $COMMITS
        \`\`\`
        "
        
        if [ -n "${{ github.event.inputs.release_notes }}" ]; then
          CHANGELOG="${{ github.event.inputs.release_notes }}
          
          $CHANGELOG"
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Commit and tag release
      run: |
        git add package.json package-lock.json 2>/dev/null || true
        git commit -m "chore: release v${{ steps.new_version.outputs.new_version }}"
        git tag -a v${{ steps.new_version.outputs.new_version }} -m "Release v${{ steps.new_version.outputs.new_version }}"
        git push origin main --tags

    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ steps.new_version.outputs.new_version }}
        release_name: Release v${{ steps.new_version.outputs.new_version }}
        body: ${{ steps.changelog.outputs.changelog }}
        draft: false
        prerelease: false
